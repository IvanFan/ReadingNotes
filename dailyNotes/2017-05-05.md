# Kubernetes

## Cluster up and running

Using minikube to create a cluster  

```
> minikube version
minikube version: v0.15.0-katacoda
```

```
> minikube start
Starting local Kubernetes cluster...
```

to check out kubectl
```
> kubectl version
Client Version: version.Info{Major:"1", Minor:"5", G
itVersion:"v1.5.2", GitCommit:"08e099554f3c31f6e6f07
b448ab3ed78d0520507", GitTreeState:"clean", BuildDat
e:"2017-01-12T04:57:25Z", GoVersion:"go1.7.4", Compi
ler:"gc", Platform:"linux/amd64"}
Server Version: version.Info{Major:"1", Minor:"5", G
itVersion:"v1.5.2", GitCommit:"08e099554f3c31f6e6f07
b448ab3ed78d0520507", GitTreeState:"clean", BuildDat
e:"1970-01-01T00:00:00Z", GoVersion:"go1.7.1", Compi
ler:"gc", Platform:"linux/amd64"}
```

check cluster details

```
> kubectl cluster-info
Kubernetes master is running at http://host01:8080
heapster is running at http://host01:8080/api/v1/pro
xy/namespaces/kube-system/services/heapster
kubernetes-dashboard is running at http://host01:808
0/api/v1/proxy/namespaces/kube-system/services/kuber
netes-dashboard
monitoring-grafana is running at http://host01:8080/
api/v1/proxy/namespaces/kube-system/services/monitor
ing-grafana
monitoring-influxdb is running at http://host01:8080
/api/v1/proxy/namespaces/kube-system/services/monito
ring-influxdb
```
We have a running master and a dashboard. The Kubernetes dashboard allows you to view your applications in a UI. During this tutorial, we’ll be focusing on the command line for deploying and exploring our application. To view the nodes in the cluster, run the kubectl get nodes command:  

```
  > kubectl get nodes
NAME      STATUS    AGE
host01    Ready     5m
```
This command shows all nodes that can be used to host our applications. Now we have only one node, and we can see that it’s status is ready (it is ready to accept applications for deployment).

## Deploy an App

Once you have a running Kubernetes cluster, you can deploy your containerized applications on top of it. To do so, you create a Kubernetes Deployment. The Deployment is responsible for creating and updating instances of your application.  

If the Node hosting an instance goes down or is deleted, the Deployment controller replaces it. This provides a self-healing mechanism to address machine failure or maintenance.  

When you create a Deployment, you'll need to specify the container image for your application and the number of replicas that you want to run. You can change that information later by updating your Deployment;  

Let’s run our first app on Kubernetes with the kubectl run command. The run command creates a new deployment. We need to provide the deployment name and app image location (include the full repository url for images hosted outside Docker hub). We want to run the app on a specific port so we add the --port parameter:

```
  > kubectl run kubernetes-bootcamp --image=docker.i
ort=8080lin/kubernetes-bootcamp:v1 --p
deployment "kubernetes-bootcamp" created
```
To list your deployments 

```  
 > kubectl get deployments
NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1         1         1            1           2m
```
To view the application output without exposing it externally, we’ll create a route between our terminal and the Kubernetes cluster using a proxy:

```
 > kubectl proxy
Starting to serve on 127.0.0.1:8001kubectl proxy
```

We now have a connection between our host (the online terminal) and the Kubernetes cluster. The started proxy enables direct access to the API. The app runs inside a Pod (we'll cover the Pod concept in next module). Get the name of the Pod and store it in the POD_NAME environment variable:  
```
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')

> echo Name of the Pod: $POD_NAME
Name of the Pod: kubernetes-bootcamp-390780338-k4k25
```

To see the output of our application, run a curl request:

```
curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/$POD_NAME/

OD_NAME/ http://localhost:8001/api/v1/proxy/namespaces/default/pods/$P
Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-390780338-k4k25
| v=1
```


# Few new concepts for flask

## Signal 

Flask supports signal and signal relevant plugins. We can use signal to decouple the big application.

For example, capturing the login and logout signal can be used for recording user activities.

## API URL Design Rules

* Only use noun for the url
* Use HTTP Request Type to control the behaviour
* Return the next link within the request 



